# Обман веб-кэша
Веб-кэши - система, расположенная между исходным сервером и пользователем. Когда пользователь запрашивает статические ресурсы, запрос сначала направляется в кэш. Если сервер не содержит кэш ресурса, запрос пересылается на исходный сервер.
![[Pasted image 20260222121634.png]]

### Ключи кэша
Когда кэш получает HTTP-запрос, он должен решить, существует ли кэшированный ответ, который можно отправить напрямую, или необходимо перенаправить запрос на исходный сервер. Кэш принимает это значения, формируя "Ключ кэша" на основе элементов HTTP-запроса

### Правила кэширования
Это инструкции, которые говорят кэшу, что можно сохранять и как долго.
- Статика (кэшируется) - файлы, которые редко меняются (картинки, стили, скрипты).
- Динамика (не кэшируется) - персональные данные, содержимое корзины, личный кабинет.
Атаки, направленные на обман веб-кэша, эксплуатируют то, как применяются правила кэширования.
Например:
1. По расширению файла. Срабатывают, если в URL есть окончание, как у статического файла, например, .js, .css.
2. По статической директории. Срабатывают, если URL  начинается с определённого префикса. Например, `/static/, `/assets`
3. По имени файла. Срабатывают на конкретные общеизвестные файлы, которые есть почти на всех сайтах. Например, robots.txt, favicon.ico.

# Создание атаки с целью обмана кэша веб-приложений
Создание атаки включает 3 шага:
1. Определить целевую конечную точку, которая возвращает динамический ответ. Стоит сосредоточиться на конечных точках, поддерживающих методы GET, HEAD или OPTIONS.
2. Выявить несоответствие в том, как кэш и исходный сервер анализирует URL. Расхождения могут быть в:
	1. Сопоставлении URL-адреса с ресурсами.
	2. Обработка символов-разделителей.
	3. Нормализация пути.
3. Создание вредоносного URL, который обманом заставит кэш сохранить динамический ответ, используя несоответствия.

### Использование сброса кэша
Чтобы тестирование было достоверным, необходимо гарантировать, что каждый тестовый запрос обрабатывается  как уникальный. Это предотвращает получение ложных результатов из-за ранее сохранённый в кэше ответов.
Решение: т.к. параметры запроса обычно являются частью кэша, самый простой способ - изменить ключ, добавить уникальную строку запроса.
**Param Miner** - инструмент для этого в Burp Suite.

### Определение получения ответа из кэша
Ключевой навык для успешной атаки - умение отличать кэшированный ответ от ответа, полученного напрямую с сервера.
Методы обнаружения:
1. Анализ заголовков ответа - основной и самый надёжный метод. Необходимо обратить внимание на:
	1. X-Cache (самый важный):
		1. hit (поражение) - ответ взят из кэша.
		2. miss (промах) - ответ получен с сервера. Обычно после этого он сохраняется в кэше.
		3. dynamic (динамика) - ответ сгенерирован на ходу, не предназначен для кэширования.
		4. refresh (обновление) - кэшированная версия устарела и была обновлена.
	2. Ceche-Control - наличие директив public и max-age (с положительным значением) говорит о том, что ресурс можно кэшировать. Но это лишь указывает на возможность, а не факт.
2. Сравнение времени ответа. Если один и тот же запрос в одном случае выполняется дольше, а в другом - очень быстро, то это признак кэширования.

# Эксплуатация правил кэширования по статическим расширениям
Атака строится на том, чтобы замаскировать запрос к динамической странице (например, с личными данными) под запрос к статичному файлу (картинке / css / скрипту), который по умолчанию кэшируется.
Предпосылки для атаки:
1. Правила кэширования: большинство CDN и кэширующих прокси настроены на кэширование файлов со статическими расширениями.
2. Несоответствие в обработке пути. Сервер и Кэш по-разному понимают URL. Например, кэш ориентируется на расширение в конце URL, а сервер может игнорировать часть пути или расширение при формировании контента.

# Несоответствие в сопоставлении путей URL
Сопоставление путей (Path mapping) - процесс связывания входного URL-адреса с конкретным ресурсом на сервере (файл, скрипт, функция).
Два основных стиля сопоставления:
1. Традиционный (Traditional URL mapping). URL напрямую отражает физическую структуру файлов системы. `http://сервер/путь/файл.html`
2. RESTful-сопоставление. URL является абстрактным и не привязан к файловой структуре. Он описывает логику работы API. `http://сервер/путь/параметр/параметр`.

### Эксплуатация в несоответствии сопоставления путей
Суть: расхождение в логике интерпретации одного и того же URL между кэширующим сервером и исходным сервером создаёт уязвимость Web Cache Deception.
Цель атаки: заставить кэш сохранить конфиденциальный динамический ответ, сделав его доступным для других пользователей.
Методики:
1. Тестирование поведения исходного сервера. Взять целевой endpoint (например, `/api/orders/123`) и добавить к нему произвольный сегмент пути. Если сервер всё равно вернул конфиденциальные данные, то он игнорирует добавленный сегмент, что создаёт условия для атаки.
2. Тестирование поведения кэша. Необходимо добавить статическое расширение к последнему (добавленному) сегменту (`/api/orders/123/foo.js`).
3. Перебрать все возможные статические расширения, которые часть кэшируют CDN: .css, .ico, .exe, .txt и т.д.
Ограничения: атака специфичная для конкретного протестированного endpoint'a. Нельзя полагаться, что одно и то же правила абстракции работает для всего сайта.
**Burp Suite Scanner** автоматически детектит такие уязвимости.
Расширение **Web Cache Deception Scanner**. Специализированный инструмент для поиска некоторых конфигураций веб-кэша.

### [[Lab 1. Exploiting path mapping for web cache deception|Lab 1: Path mapping]]

# Несоответствие разделителей
Разделители - символы или строки, определяющие граница между элементами URL. Несмотря на общую стандартизацию их использования (например, "?" - отделяет путь от строки запроса). RFC для URL оставляет пространство для интерпретаций, что приводит к различия в работе на разных фреймворках и технологиях.

Пример атаки:
	Например, URL: `/profile;foo.css`
	Исходный сервер на фреймворке Java Spring воспринимает как разделитель, игнорируя всё после ;.
	Кэш не знает о матричных переменных и не считает ";" разделителем. Путь /profile;foo.css он воспринимает как запрос к файлу.
	
Та же логика применима к любым символам, чья роль разделителя отличается для кэша и бэкэнда.
Пример атаки:
	Рассмотри поведение фреймворка Ruby on Rails, который использует точку для определения формата ответа.
	1. Запрос `/profile` обработается стандартным HTML-обработчиком и возвращает страницу.
	2. Запрос к `/profile.css` распознается как запрос к css-файлу. Т.к. обработчика для css нет, сервер возвращает ошибку.
	3. Запрос `/profile.ico` содержит неизвестное фреймворку расширение. Т.к. он не знает что делать, запрос передаётся HTML-обработчику.

Разделителями могут выступать не только стандартные символы, но и закодированные последовательности.
Пример атаки:
	Запрос по `/profile%00foo.js`
	%00 - нуль символ.
	Исходный сервер на OpenLiteSpeeed использует закодированный нуль символ как разделитель. Он обрезает путь после `/profile` и обрабатывает именно этот ресурс, возвращая страницу профиля.
	Кэш на Akamai или Fastly. Эти CDN не считают %00 разделителем и воспринимают путь `/profile%00foo.js` как запрос к JavaScript-файлу. Другие CDN возвращают ошибку при нуль-символе, а Akami и Fastly - нет.

### Эксплуатация несоответствий разделителей.
Общая стратегия эксплуатации заключается в добавлении к пути статического расширения, которое будет распознано кэшем, но проигнорировано сервером. Ключевая задача - найти символ, который сервер считает разделителем, а кэш - нет.
Методика поиска разделителя:
	1. Необходимо выбрать endpoint, который возвращает конфиденциальные данные, а затем к нему добавить подстроку `/users/llisaaa`. *Важно: если ответ `/users/list` == `/users/listaaa`, то запрос перенаправляется и необходимо выбрать другой endpoint.*
	2. Тестирование символа - кандидата. Выбирается потенциальный символ - разделитель и вставляется в запрос `/users/list;aaa`, если` /users/list;aaa` == `/users/list`, значит сервер распознал ";" как разделитель.
	3. После нахождения символа - разделителя необходимо проверить: является ли он для кэша тоже разделителем или нет. Необходимо вставить в конце пути статическое расширение, если ответ закэширован, то кэш не использует этот разделитель и обрабатывает полный путь целиком.
Поиск символов-разделителей можно осуществить при помощи **Burp Intruder**, при этом необходимо выключить **Payload encoding**.

Когда найден разделитель, который игнорируется кэшем, можно собрать атаку:
1. **Структура**: Добавляем к реальному пути разделитель и фиктивное статическое расширение.  Пример: `/settings/users/list;aaa.js`
2. Как это работает:
    - **Кэш видит:** `/settings/users/list;aaa.js` → думает, что это статический JS-файл → применяет правило кэширования.
    - **Сервер видит:** `/settings/users/list` (отбрасывает всё после `;`) → возвращает реальные динамические данные (профиль)
3. **Результат:** Динамические данные профиля попадают в кэш и становятся доступны злоумышленнику.

**Масштабирование:** Если разделитель работает на одном эндпоинте, скорее всего, он сработает и на других — серверы используют разделители последовательно.

**Важное ограничение (браузер):**  Не все разделители можно отправить как есть — браузер может их изменить:
- `{`, `}`, `<`, `>` — браузер URL-кодирует
- `#` — браузер обрезает всё, что после него (не доходит до сервера)
**Обход:** Если кэш или сервер декодируют символы, можно отправлять их в закодированном виде (например, `%7B` вместо `{`).

### [[Lab 2. Exploiting path delimiters for web cache deception|Lab 2: Path delimiters]]